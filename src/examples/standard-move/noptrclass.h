#ifndef NOPTRCLASS_H
#define NOPTRCLASS_H

#include <QString>

class NoPtrClass {
public:
    NoPtrClass() = default;

    /*!
     * \brief NoPtrClass - обычно все поля в конструкторе копирования присваюваются в списке
     * инициализации, он забирает себе все поля другого класса(копируя их). Внимание - все поля
     * в списке инициализации должны быть присвоены в порядке их объявления(я думаю тут понятно
     * сверху вниз в порядке их объявления в классе(это общепринятая практика)).
     *
     * P.S. - Почему присваивание происходит списком инициализации? Потому что у переменной
     * m_value не вызовется стандартный конструктор. В некоторых случаях стандартный конструктор
     * может затрачивать большое количество времени это просто хорошая практика в
     * програмировании так писать. Но для QString впринципе
     * это роли не играет.
     */
    NoPtrClass(const NoPtrClass &other) : m_value(other.m_value) {}

    /*!
     * \brief NoPtrClass - Тут тоже самое как и конструктор копирования за исключением некоторых
     * моментов.
     *
     * 1) Как правило конструктор перемещения, не кидает исключения не при каких
     * раскладах, он не выделяет памяти, он просто забирает все поля другого класса себе. Это
     * позволяет компилятору понять что тут можно оптимизировать ассемблерский код(Это
     * немного сложно тут лучше почитать в интернете но суть я думаю понятна). Для того чтобы
     * пометить его как конструктор не кидающий исключения я использую qt-макрос
     * Q_DECL_NOEXCEPT(В нашем случае это обычное встроенное слово в с++ "noexcept").
     * Почему макрос? потому что есть возможность отключить эту опцию и тогда макрос будет
     * просто пустым словом или может быть это слово не поддерживается в другом стандарте,
     * вообщем макрос лучше потому что он сам вычислит это все и он является кросс-платформенным
     * по своей сути тебе не нужно задумываться как правильно писать. Суть я думаю понятна.
     *
     * 2) Далее std::move() - ты принудительно указываешь компилятору что other.m_value является
     * временным объектом и он создаст твою m_value не конструктором копирования а конструктором
     * перемещения строки.
     *
     * 3) Важный момент который надо понять в move-семантике - как только ты передал rvalue
     * объект(то есть временный в функцию или в конструктор это не важно) ОН ПЕРЕСТАЁТ БЫТЬ
     * ВРЕМЕННЫМ ОБЪЕКТОМ И ДЛЯ ТОГО ЧТОБЫ ПЕРЕДАТЬ ЕГО ДАЛЬШЕ КАК ВРЕМЕННЫЙ ОБЪЕКТ в функцию
     * или конструктор тебя опять нужно вызвать std::move для него
     */
    NoPtrClass(NoPtrClass &&other) Q_DECL_NOEXCEPT : m_value(std::move(other.m_value)) {}

    /*!
     * \brief operator= - оператор присваивания копированием, тут тоже самое что и конструктор
     * копирования(только не списком инициализации), только желательно проверить что объект не
     * указывает на одну и ту же область памяти(Защита от даунов) NoPtrClass a; a = a = даун;
     */
    NoPtrClass &operator=(const NoPtrClass &other)
    {
        if (this != &other) {
            m_value = other.m_value;
        }
        return *this;
    }

    /*!
     * \brief operator = Тут тоже самое только c std::move
     */
    NoPtrClass &operator=(NoPtrClass &&other)
    {
        if (this != &other) {
            m_value = std::move(other.m_value);
        }
        return *this;
    }

private:
    QString m_value;
};

#endif // NOPTRCLASS_H
